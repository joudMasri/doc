<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>library documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">library documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content class">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Classes</li>
  <li >Filters</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>projects/ngx-interphase/src/lib/modules/table/table/table.component.ts</code>
        </p>






            <section>
    <h3 id="index">Index</h3>
    <table class="table table-sm table-bordered index-table">
        <tbody>
                <tr>
                    <td class="col-md-4">
                        <h6><b>Properties</b></h6>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <ul class="index-list">
                            <li>
                                <a href="#column" >column</a>
                            </li>
                            <li>
                                    <span class="modifier">Optional</span>
                                <a href="#searchAction" >searchAction</a>
                            </li>
                            <li>
                                <a href="#searchKey" >searchKey</a>
                            </li>
                        </ul>
                    </td>
                </tr>






        </tbody>
    </table>
</section>


            <section>
    
    <h3 id="inputs">
        Properties
    </h3>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="column"></a>
                    <span class="name">
                        <span ><b>column</b></span>
                        <a href="#column"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="../classes/Column.html" target="_self" >Column</a></code>

                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="14" class="link-to-prism">projects/ngx-interphase/src/lib/modules/table/table/table.component.ts:14</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="searchAction"></a>
                    <span class="name">
                            <span class="modifier">Optional</span>
                        <span ><b>searchAction</b></span>
                        <a href="#searchAction"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" >any</a></code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>null</code>
                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="16" class="link-to-prism">projects/ngx-interphase/src/lib/modules/table/table/table.component.ts:16</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="searchKey"></a>
                    <span class="name">
                        <span ><b>searchKey</b></span>
                        <a href="#searchKey"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" >any</a></code>

                    </td>
                </tr>
                    <tr>
                        <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="15" class="link-to-prism">projects/ngx-interphase/src/lib/modules/table/table/table.component.ts:15</a></div>
                        </td>
                    </tr>


        </tbody>
    </table>
</section>







    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Component, Input, OnInit, Output, EventEmitter, ViewChildren, QueryList, ElementRef, AfterContentInit, ChangeDetectorRef, AfterContentChecked } from &#x27;@angular/core&#x27;;
import { faCheck,
  faSort, faSortAmountDown, faSortAmountUpAlt, faTimes, faPlus, faAngleDoubleLeft, faAngleDoubleRight,
  faChevronLeft, faChevronRight, faFilter, faEllipsisH, faCircle,  faListOl, faBorderAll, faSearch, faSlidersH, faChevronUp, faChevronDown, faEllipsisV, faFilterCircleXmark, faPencil } from &#x27;@fortawesome/free-solid-svg-icons&#x27;;
import { IconDefinition, faTrashAlt, faMinusSquare } from &#x27;@fortawesome/free-regular-svg-icons&#x27;;
import { CurrencyPipe } from &#x27;@angular/common&#x27;;
import { ReactiveInputComponent } from &#x27;./../../reactive-input/reactive-input/reactive-input.component&#x27;;
import { CheckboxComponent } from &#x27;./../../checkbox/checkbox/checkbox.component&#x27;;
import { FileComponent } from &#x27;./../../file/file/file.component&#x27;;
import { Column } from &#x27;../../../models/column&#x27;;
import { SelectComponent } from &#x27;../../select/select/select.component&#x27;;
import { FilterCardComponent } from &#x27;./../../filter-card/filter-card/filter-card.component&#x27;;
export class Filters {
  column!: Column;
  searchKey: any;
  searchAction?: any &#x3D; null;
}
@Component({
  selector: &#x27;lib-table&#x27;,
  templateUrl: &#x27;./table.component.html&#x27;,
  styleUrls: [&#x27;./table.component.scss&#x27;],
  providers: [CurrencyPipe],
})
export class TableComponent implements OnInit, AfterContentInit, AfterContentChecked {

  constructor(
    private currencyPipe: CurrencyPipe,
    private cdref: ChangeDetectorRef,
  ) { }


  ngAfterContentChecked() {
    this.cdref.detectChanges();
  }
  ngAfterViewInit() {
    this.cdref.detectChanges();
  }
  ngAfterContentInit(): void {
    this.results &#x3D; this.items;
    this.cdref.detectChanges();
  }
  ngOnInit(): void {
  }

  faCheck &#x3D; faCheck;
  faSort &#x3D; faSort;
  faFilter &#x3D; faFilter;
  faSortDown &#x3D; faSortAmountDown; // asc
  faSortUp &#x3D; faSortAmountUpAlt; // desc
  faTrash &#x3D; faTrashAlt;
  faTimes &#x3D; faTimes;
  faPlus &#x3D; faPlus;
  faAngleDoubleLeft &#x3D; faAngleDoubleLeft;
  faAngleDoubleRight &#x3D; faAngleDoubleRight;
  faChevronLeft &#x3D; faChevronLeft;
  faChevronRight &#x3D; faChevronRight;
  faEllipsis &#x3D; faEllipsisH;
  faChevronUp &#x3D; faChevronUp;
  faChevronDown &#x3D; faChevronDown;
  faCircle &#x3D; faCircle;
  faSearch &#x3D; faSearch;
  faSliders &#x3D; faSlidersH;
  faMinusSquare &#x3D; faMinusSquare;
  faMore &#x3D; faEllipsisV;
  faFilterX &#x3D; faFilterCircleXmark;
  faPencil &#x3D; faPencil;
  stickyHeader &#x3D; true;


  @ViewChildren(&#x27;editInputsRef&#x27;) editInputsRef!: QueryList&lt;ReactiveInputComponent&gt;;
  @ViewChildren(&#x27;addInputsRef&#x27;) addInputsRef!: QueryList&lt;ReactiveInputComponent&gt;;
  @ViewChildren(&#x27;addCheckboxesRef&#x27;) addCheckboxesRef!: QueryList&lt;CheckboxComponent&gt;;
  @ViewChildren(&#x27;editCheckboxesRef&#x27;) editCheckboxesRef!: QueryList&lt;CheckboxComponent&gt;;
  @ViewChildren(&#x27;filterInputsRef&#x27;) filterInputsRef!: QueryList&lt;ElementRef&gt;;
  @ViewChildren(&#x27;filtersSelectsRef&#x27;) filtersSelectsRef!: QueryList&lt;SelectComponent&gt;;
  @ViewChildren(&#x27;fileUploadRef&#x27;) fileUploadRef!: QueryList&lt;FileComponent&gt;;
  @ViewChildren(&#x27;editSelectRef&#x27;) editSelectRef!: QueryList&lt;SelectComponent&gt;;
  @ViewChildren(&#x27;numberFilterRef&#x27;) numberFilterRef!: QueryList&lt;FilterCardComponent&gt;;
  @ViewChildren(&#x27;filtersChecklistsRef&#x27;) filtersChecklistsRef!: QueryList&lt;CheckboxComponent&gt;;

  @Input(&#x27;items&#x27;) items: any[] &#x3D; [];
  @Input(&#x27;columns&#x27;) columns: Column[] &#x3D; [];
  @Input(&#x27;groupName&#x27;) groupName: string &#x3D; &#x27;item&#x27;;
  @Input(&#x27;localStorage&#x27;) localStorage: boolean &#x3D; true;
  @Input(&#x27;pagination&#x27;) pagination: boolean &#x3D; true;
  @Input(&#x27;itemsPerPage&#x27;) itemsPerPage: number &#x3D; 0;
  @Input(&#x27;totalItemsCount&#x27;) totalItemsCount: number &#x3D; 0;
  @Input(&#x27;pageInfo&#x27;) pageInfo: boolean &#x3D; true;
  @Input(&#x27;currentPage&#x27;) currentPage: number &#x3D; 1;
  @Input(&#x27;class&#x27;) class: string &#x3D; &#x27;&#x27;;

  @Output(&#x27;onEdit&#x27;) editEmitter &#x3D; new EventEmitter();
  @Output(&#x27;onAdd&#x27;) addEmitter &#x3D; new EventEmitter();
  @Output(&#x27;onDelete&#x27;) deleteEmitter &#x3D; new EventEmitter();
  @Output(&#x27;onSort&#x27;) onSort &#x3D; new EventEmitter();
  @Output(&#x27;onFilter&#x27;) onFilter &#x3D; new EventEmitter();
  @Output(&#x27;onPaginate&#x27;) onPaginate &#x3D; new EventEmitter();

  get totalPagesCount() {
    let fullPagesCount &#x3D; Math.floor(this.itemsCount / this.itemsPerPage);
    return this.itemsCount % this.itemsPerPage !&#x3D;&#x3D; 0 ? fullPagesCount + 1 : fullPagesCount;
  }

  get itemsCount() {
    return this.totalItemsCount ? this.totalItemsCount : this.items.length;
  }

  // data
  hiddenColumns: string[] &#x3D; [];
  hideColumn(key: string) {
    this.hiddenColumns.push(key);
    const column &#x3D; this.columns.find(c &#x3D;&gt; c.key &#x3D;&#x3D;&#x3D; key);
    if (column) column.hidden &#x3D; true;
  }
  unhideColumn(key: string) {
    this.hiddenColumns &#x3D; this.hiddenColumns.filter(k &#x3D;&gt; k !&#x3D;&#x3D; key);
    const column &#x3D; this.columns.find(c &#x3D;&gt; c.key &#x3D;&#x3D;&#x3D; key);
    if (column) column.hidden &#x3D; false;
  }
  keepOrder &#x3D; (a: any, b: any) &#x3D;&gt; a;
  getColumn(key: any) : any {
    let column &#x3D; {};
    for (let i &#x3D; 0; i &lt; this.columns.length; i++) {
      const element &#x3D; this.columns[i];
      if (element.key &#x3D;&#x3D;&#x3D; key) {
        column &#x3D; element;
      }
    }
    return column;
  }
  getTransformedValue(obj: any) {
    let column: Column &#x3D; this.getColumn(obj.key);
    if (column.type &#x3D;&#x3D;&#x3D; &#x27;currency&#x27;)
      return this.currencyPipe.transform(obj.value);
    return obj.value;
  }

  // selection
  selectedItems: any[] &#x3D; [];
  toggleAll() {
    let group &#x3D; this.filters.length &gt; 0 ? this.results : this.items;
    this.selectedItems.length &#x3D;&#x3D;&#x3D; group.length? this.selectedItems &#x3D; [] : this.selectedItems &#x3D; group;
  }

  toggleItem(item: any) {
    if (this.selectedItems.includes(item))
      this.selectedItems &#x3D; this.selectedItems.filter(i &#x3D;&gt; i !&#x3D;&#x3D; item);
    else this.selectedItems.push(item);
  }

  cancelFocus() {
    this.selectedItems &#x3D; [];
    this.focusedItem &#x3D; null;
  }

  getFocus(item: any) {
    this.selectedItems &#x3D; [];
    this.toggleItem(item);
    this.focusedItem &#x3D; item;
  }
  // sort
  sortedColumnKey: string | null &#x3D; null;
  sortedColumnIcon!: IconDefinition;
  setSortedColumnIcon(key: string) {
    this.sortedColumnKey &#x3D; key;
    if (this.sortedColumnIcon &#x3D;&#x3D;&#x3D; this.faSortUp) {
      this.sortedColumnIcon &#x3D; this.faSortDown;
      if (!this.localStorage) return this.onSort.emit({property: key, direction: &#x27;desc&#x27;});
      else return this.items.sort((a, b) &#x3D;&gt; {
        var x &#x3D; this.getColumn(key).type &#x3D;&#x3D;&#x3D; &#x27;person&#x27; ? (a as any)[key].name : (a as any)[key];
        var y &#x3D; this.getColumn(key).type &#x3D;&#x3D;&#x3D; &#x27;person&#x27; ? (b as any)[key].name : (b as any)[key];
        return ((x &lt; y) ? 1 : ((x &gt; y) ? -1 : 0));
      })
    } else {
      this.sortedColumnIcon &#x3D; this.faSortUp;
      if (!this.localStorage) return this.onSort.emit({property: key, direction: &#x27;asc&#x27;});
      else return this.items.sort((a, b) &#x3D;&gt; {
        var x &#x3D; this.getColumn(key).type &#x3D;&#x3D;&#x3D; &#x27;person&#x27; ? (a as any)[key].name : (a as any)[key];
        var y &#x3D; this.getColumn(key).type &#x3D;&#x3D;&#x3D; &#x27;person&#x27; ? (b as any)[key].name : (b as any)[key];
        return ((x &lt; y) ? -1 : ((x &gt; y) ? 1 : 0));
      })
    }
  }

  // delete
  deleteItem(item: any) {
    this.deleteEmitter.emit([item]);
    this.selectedItems &#x3D; [];
  }

  deleteAll() {
    this.deleteEmitter.emit(this.selectedItems);
    this.selectedItems &#x3D; [];
  }

  // edit
  focusedItem: any &#x3D; null;
  dummyItem: any &#x3D; {};
  get isItemValid() : boolean {
    let isValid &#x3D; true;
    this.editInputsRef.forEach(input &#x3D;&gt; {
      if (input.invalid &amp;&amp; input.required) {
        isValid &#x3D; false
      }
    });
    if (this.editCheckboxesRef) this.editCheckboxesRef.forEach(checklist &#x3D;&gt; {
      if (checklist.invalid &amp;&amp; checklist.required) {
        isValid &#x3D; false;
      }
    })
    return isValid;
  }

  getImageName(imageUrl: any) {
    let arr &#x3D; [];
    arr &#x3D; imageUrl.split(&quot;/&quot;);
    return arr[arr.length - 1];
  }
  edit() {
    let newItem: any &#x3D; {};
    if (this.focusedItem &amp;&amp; this.isItemValid) {
      this.editInputsRef.forEach(input &#x3D;&gt; {
        newItem[input.name] &#x3D;
          input.type &#x3D;&#x3D;&#x3D; &#x27;number&#x27; ? +input.value : input.value;
      })

      for (let i &#x3D; 0; i &lt; this.columns.length; i++) {
        const column &#x3D; this.columns[i];
        if (column.type &#x3D;&#x3D;&#x3D; &#x27;boolean&#x27;) {
          newItem[column.key] &#x3D; this.dummyItem[column.key] || this.focusedItem[column.key]
        }

        if (column.type &#x3D;&#x3D;&#x3D; &#x27;array&#x27;) {
          newItem[column.key] &#x3D; this.dummyItem[column.key] || this.focusedItem[column.key]
        }

        if (column.type &#x3D;&#x3D;&#x3D; &#x27;image&#x27;) {
          newItem[column.key] &#x3D; this.dummyItem[column.key] || this.focusedItem[column.key]
        }

        if (column.hidden) {
          newItem[column.key] &#x3D; this.focusedItem[column.key]
        }
      }

      this.editEmitter.emit({new: newItem, previous: this.focusedItem});
      this.focusedItem &#x3D; null;
      this.selectedItems &#x3D; [];
      this.dummyItem &#x3D; {};
    }
  }
  setBooleansValues(key: any, value: boolean) {
    this.dummyItem[key] &#x3D; value;
  }
  setArraysValues(key: any, $event: any[]) {
    this.dummyItem[key] &#x3D; $event;
  }

  setFilesValues(key: any, $event: any[]) {
    this.dummyItem[key] &#x3D; $event[0]
  }
  getArrayItems(arr: any) {
    let array: any[] &#x3D; [];
    arr.forEach((element: any) &#x3D;&gt; {
      array.push(element)
    });

    return array;
  }

  getPersonValues(obj: any) {
    return { avatar: obj.avatar, name: obj.name}
  }
  getSelectedOptions(arr: any) {
    let array: any[] &#x3D; [];
    arr.forEach((element: any) &#x3D;&gt; {
      array.push(element)
    });

    return array;
  }

  getOriginalFiles(value: any) {
    return value;
  }

  // creation
  creationMode &#x3D; false;
  get isFormValid() : boolean {
    let isValid &#x3D; true;
    this.addInputsRef.forEach(input &#x3D;&gt; {
      if (input.isValid &amp;&amp; !this.isReadonly(input.name))
        isValid &#x3D; false;
    });
    if (this.addCheckboxesRef) this.addCheckboxesRef.forEach(checkbox &#x3D;&gt; {
      if (checkbox.isValid &amp;&amp; !this.isReadonly(checkbox.name))
        isValid &#x3D; false;
    })
    if (this.fileUploadRef) this.fileUploadRef.forEach(fileUploader &#x3D;&gt; {
      if (!fileUploader.isValid &amp;&amp; fileUploader.required &amp;&amp; !this.isReadonly(fileUploader.name))
        isValid &#x3D; false;
    })

    return isValid;
  }

  isReadonly(key: any) {
    let readonly &#x3D; false;
    for (let i &#x3D; 0; i &lt; this.columns.length; i++) {
      const element &#x3D; this.columns[i];
      if (element.key &#x3D;&#x3D;&#x3D; key &amp;&amp; element.readonly !&#x3D;&#x3D; undefined) {
        readonly &#x3D; element.readonly;
      }
    }
    return readonly;
  }
  addItem() {
    let newItem: any &#x3D; {};
    this.addInputsRef.forEach(input &#x3D;&gt; {
      newItem[input.name] &#x3D;
        input.type &#x3D;&#x3D;&#x3D; &#x27;number&#x27; ? +input.value : input.value;
    })
    for (let i &#x3D; 0; i &lt; this.columns.length; i++) {
      const column &#x3D; this.columns[i];
      if (column.type &#x3D;&#x3D;&#x3D; &#x27;boolean&#x27;) {
        newItem[column.key] &#x3D; this.dummyItem[column.key] || false;
      }
      if (column.type &#x3D;&#x3D;&#x3D; &#x27;array&#x27;) {
        newItem[column.key] &#x3D; this.dummyItem[column.key] || this.addCheckboxesRef.forEach(element &#x3D;&gt; {
          if (element.name &#x3D;&#x3D;&#x3D; column.key)
            return element.selectedOptions;
          else return [];
        });
      }
      if (column.type &#x3D;&#x3D;&#x3D; &#x27;image&#x27;) {
        newItem[column.key] &#x3D; this.dummyItem[column.key] || this.fileUploadRef.forEach(element &#x3D;&gt; {
          if (element.name &#x3D;&#x3D;&#x3D; column.key)
            return element.originalFiles[0];
          else return null;
        })
      }
    }
    this.addEmitter.emit(newItem);
    this.creationMode &#x3D; false;
  }

  filterMode &#x3D; false;

  resetSingleFilterInput(type: string, key: string) {
    switch (type) {
      case &#x27;boolean&#x27;:
        this.filtersSelectsRef.forEach(element &#x3D;&gt; {
          element.name &#x3D;&#x3D;&#x3D; key ? element.selectedOption &#x3D; null : null
        });
        break;

      case &#x27;array&#x27;:
        this.filtersChecklistsRef.forEach(element &#x3D;&gt; {
          element.name &#x3D;&#x3D;&#x3D; key ? element.selectedOptions &#x3D; [] : null;
        })
        break;

      default:
        this.filterInputsRef.forEach(element &#x3D;&gt; {
          element.nativeElement.name &#x3D;&#x3D;&#x3D; key ? element.nativeElement.value &#x3D; &#x27;&#x27; : null;
        });
        break;
    }
  }

  resetFilters() {
    this.filterMode &#x3D; false;
    this.filterInputsRef.forEach(input &#x3D;&gt; {
      input.nativeElement.value &#x3D; null;
    })
    this.numberFilterRef.forEach(f &#x3D;&gt; {
      f.onClear();
    })
    this.filtersSelectsRef.forEach(comp &#x3D;&gt; {
     if (comp.options) comp.selectedOption &#x3D; null
    })
    this.filtersChecklistsRef.forEach(element &#x3D;&gt; {
      element.selectedOptions &#x3D; []
    });
    this.filters &#x3D; [];
    this.results &#x3D;
      this.localStorage ? this.items.slice((this.currentPage - 1) * this.itemsPerPage, this.itemsPerPage * this.currentPage)
      : this.items;
  }

  results: any[] &#x3D; [];
  displayFilters &#x3D; false;
  get itemsToDisplay() {
    return this.filters.length &gt; 0 ? this.results :
      this.items.slice((this.currentPage - 1) * this.itemsPerPage, this.itemsPerPage * this.currentPage);
  }

  filters: Filters[] &#x3D; [];
  filteredOn(key: string) {
    return this.filters.filter(x &#x3D;&gt; x.column.key &#x3D;&#x3D;&#x3D; key).length &gt; 0;
  }
  removeFilter(key: string) {
    this.filters &#x3D; this.filters.filter(x &#x3D;&gt; x.column.key !&#x3D;&#x3D; key);
    this.reapplyFilters();
  }
  addFilter(filters: Filters) {
    this.filters.push(filters);
  }
  filterByAction(filters: Filters) {
    this.addFilter(filters);
    switch (filters.column.type) {
      case &#x27;number&#x27;:
      this.filterNumber(filters.column.key, filters.searchAction.value, filters.searchKey);
        break;

      default:
        this.filterString(filters.column.key, filters.searchAction.value, filters.searchKey);
        break;
    }
  }

  filterNumber(key: string, value: number, target: number) {
    this.filterMode &#x3D; true;
    let items: any[] &#x3D; [];
    switch (value) {
      case 0:
        for (let i &#x3D; 0; i &lt; this.results.length; i++) {
          if (this.results[i][key] &#x3D;&#x3D;&#x3D; target) {
            items.push(this.results[i])
          }
        }
        break;

      case 1:
        for (let i &#x3D; 0; i &lt; this.results.length; i++) {
          if (this.results[i][key] !&#x3D;&#x3D; target) {
            items.push(this.results[i])
          }
        }

        break;

      case 2:
        for (let i &#x3D; 0; i &lt; this.results.length; i++) {
          if (this.results[i][key] &lt; target) {
            items.push(this.results[i])
          }
        }

        break;

      case 3:
        for (let i &#x3D; 0; i &lt; this.results.length; i++) {
          if (this.results[i][key] &lt;&#x3D; target) {
            items.push(this.results[i])
          }
        }

        break;

      case 4:
        for (let i &#x3D; 0; i &lt; this.results.length; i++) {
          if (this.results[i][key] &gt; target) {
            items.push(this.results[i])
          }
        }

        break;

      case 5:
        for (let i &#x3D; 0; i &lt; this.results.length; i++) {
          if (this.results[i][key] &gt;&#x3D; target) {
            items.push(this.results[i])
          }
        }

      break;

    }

    this.results &#x3D; this.results.filter(x &#x3D;&gt; items.includes(x));
  } // tested

  filterString(key: string, option: number, target: string) {
    this.filterMode &#x3D; true;
    let items: any[] &#x3D; [];
    switch (option) {
      case 0:
        for (let i &#x3D; 0; i &lt; this.results.length; i++) {
          const value: string &#x3D; this.getColumn(key).type &#x3D;&#x3D;&#x3D; &#x27;person&#x27; ?
          this.results[i][key].name.toString().toLowerCase() :
          this.results[i][key].toString().toLowerCase();
          if (value.startsWith(target)) {
            items.push(this.results[i])
          }
        }
        break;

      case 1:
        for (let i &#x3D; 0; i &lt; this.results.length; i++) {
          const value: string &#x3D; this.getColumn(key).type &#x3D;&#x3D;&#x3D; &#x27;person&#x27; ?
          this.results[i][key].name.toString().toLowerCase() :
          this.results[i][key].toString().toLowerCase();
          if (value.includes(target)) {
            items.push(this.results[i])
          }
        }
        break;

      case 2:
        for (let i &#x3D; 0; i &lt; this.results.length; i++) {
          const value: string &#x3D; this.getColumn(key).type &#x3D;&#x3D;&#x3D; &#x27;person&#x27; ?
          this.results[i][key].name.toString().toLowerCase() :
          this.results[i][key].toString().toLowerCase();
          if (!value.includes(target)) {
            items.push(this.results[i])
          }
        }
        break;

      case 3:
        for (let i &#x3D; 0; i &lt; this.results.length; i++) {
          const value: string &#x3D; this.getColumn(key).type &#x3D;&#x3D;&#x3D; &#x27;person&#x27; ?
          this.results[i][key].name.toString().toLowerCase() :
          this.results[i][key].toString().toLowerCase();
          if (value.endsWith(target)) {
            items.push(this.results[i])
          }
        }
        break;

      case 4:
        for (let i &#x3D; 0; i &lt; this.results.length; i++) {
          const value: string &#x3D; this.getColumn(key).type &#x3D;&#x3D;&#x3D; &#x27;person&#x27; ?
          this.results[i][key].name.toString().toLowerCase() :
          this.results[i][key].toString().toLowerCase();
          if (value &#x3D;&#x3D;&#x3D; target) {
            items.push(this.results[i])
          }
        }
        break;

      case 5:
        for (let i &#x3D; 0; i &lt; this.results.length; i++) {
          const value: string &#x3D; this.getColumn(key).type &#x3D;&#x3D;&#x3D; &#x27;person&#x27; ?
          this.results[i][key].name.toString().toLowerCase() :
          this.results[i][key].toString().toLowerCase();
          if (value !&#x3D;&#x3D; target) {
            items.push(this.results[i])
          }
        }
        break;
    }

    this.results &#x3D; this.results.filter(x &#x3D;&gt; items.includes(x));
    console.log(this.results)
  } // tested
  // ()!
  filterByKey(column: Column, searchKey: any, exact?: boolean) {
    let filters &#x3D; {column: column, searchKey: searchKey}
    this.addFilter(filters);
    this.filterMode &#x3D; true;
    switch (column.type) {

      case &#x27;person&#x27;:
        let personItems: any[] &#x3D; [];
        for (let i &#x3D; 0; i &lt; this.results.length; i++) {
          if (this.results[i][column.key].name.toLowerCase().includes(searchKey)) {
            personItems.push(this.results[i])
          }
        }
        this.results &#x3D; this.results.filter(x &#x3D;&gt; personItems.includes(x))
        break;

      case &#x27;boolean&#x27;:
        let booleanItems: any[] &#x3D; [];

        if (searchKey &#x3D;&#x3D;&#x3D; column.name) {
          this.removeFilter(column.key);
        }
        else {
          // this.reapplyFilters();
          for (let i &#x3D; 0; i &lt; this.results.length; i++) {
            if (this.results[i][column.key] &#x3D;&#x3D;&#x3D; searchKey.value) {
              booleanItems.push(this.results[i]);
            }
          }

          this.results &#x3D; this.results.filter(x &#x3D;&gt; booleanItems.includes(x))
        }

        break;
      // ()!
      case &#x27;array&#x27;:
        let arrayItems: any[] &#x3D; [];

        if (searchKey.length &#x3D;&#x3D;&#x3D; 0) {
          this.removeFilter(column.key);
        } else {
          if (!exact) {
            for (let i &#x3D; 0; i &lt; this.results.length; i++) {
              for (let ii &#x3D; 0; ii &lt; this.results[i][column.key].length; ii++) {
                const element &#x3D; this.results[i][column.key][ii];
                searchKey.forEach((k: any) &#x3D;&gt; {
                  if (k.label &#x3D;&#x3D;&#x3D; element.label) {
                    arrayItems.push(this.results[i]);
                  }
                });
              }

            }
          } else {
            for (let i &#x3D; 0; i &lt; this.results.length; i++) {
              let firstArray &#x3D; JSON.stringify(this.results[i][column.key])
              let secondArray &#x3D; JSON.stringify(searchKey);
              if (firstArray &#x3D;&#x3D;&#x3D; secondArray) {
                arrayItems.push(this.results[i]);
              }
            }
          }
          this.results &#x3D; this.results.filter(x &#x3D;&gt; arrayItems.includes(x));
        }


        break;

      default:
        let items: any[]&#x3D; [];
        for (let i &#x3D; 0; i &lt; this.results.length; i++) {
          if (this.results[i][column.key].toLowerCase().includes(searchKey)) {
            items.push(this.results[i])
          }
        }
      this.results &#x3D; this.results.filter(x &#x3D;&gt; items.includes(x))
      break;

    }

    console.log()
  } // tested

  applyFilters(filters: Filters, exact?: boolean) {
    this.filterMode &#x3D; true;
    this.filteredOn(filters.column.key) ? this.removeFilter(filters.column.key) : null;
    if (filters.searchAction) {
      this.filterByAction(filters);
    } else {
      this.filterByKey(filters.column, filters.searchKey, exact);
    }
  }

  reapplyFilters() {
    this.results &#x3D; this.items;
    if(this.filters.length &gt; 0) {
      this.filters.forEach(element &#x3D;&gt; {
        this.applyFilters(element)
      });
    }
  }

  backspace(filters: Filters) {
    this.filteredOn(filters.column.key) ? this.removeFilter(filters.column.key) : null;
    if (filters.searchKey.length &gt; 0) {
      this.addFilter(filters);
    } else {
      this.reapplyFilters();
    }
  }

  getValueFromEvent($event: any) {
    return $event.target.value;
  }

  // pagination
  paginate() {
    this.filterMode &#x3D; false;
    this.resetFilters();
    if (!this.localStorage) this.onPaginate.emit(this.currentPage);
  }

  get pages() : string[] {
    let pages: string[] &#x3D; [&#x27;1&#x27;];
    for (let i &#x3D; 0; i &lt;&#x3D; this.totalPagesCount; i++) {
      if (this.totalPagesCount &gt;&#x3D; 20) {
        if (i !&#x3D;&#x3D; 0 &amp;&amp; i % 5 &#x3D;&#x3D;&#x3D; 0) {
          pages.push(i.toString())
        }
      } else {
        if (i !&#x3D;&#x3D; 0 &amp;&amp; i % 3 &#x3D;&#x3D;&#x3D; 0) {
          pages.push(i.toString())
        }
      }

    };

    if (!pages.includes(this.totalPagesCount.toString())) {
      pages.pop();
      pages.push(this.totalPagesCount.toString());
    }

    return pages;
  }

  closeExistingCards(index: number) {
    this.numberFilterRef.forEach(r &#x3D;&gt; {
      if (r.index !&#x3D;&#x3D; index) {
        r.show &#x3D; false;
      }
    })
  }

}
</code></pre>
    </div>
</div>









                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'class';
            var COMPODOC_CURRENT_PAGE_URL = 'Filters.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
